<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NSW Criminal Law Legislative Intelligence System</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f8f9fa;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .header p {
            font-size: 1.1em;
            opacity: 0.9;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }

        .panel {
            background: white;
            border-radius: 10px;
            padding: 25px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            border-left: 4px solid #2a5298;
        }

        .panel h2 {
            color: #1e3c72;
            margin-bottom: 20px;
            font-size: 1.3em;
            border-bottom: 2px solid #e9ecef;
            padding-bottom: 10px;
        }

        .file-upload-area {
            border: 2px dashed #ddd;
            border-radius: 8px;
            padding: 20px;
            text-align: center;
            margin-bottom: 20px;
            transition: all 0.3s ease;
        }

        .file-upload-area:hover {
            border-color: #2a5298;
            background-color: #f8f9ff;
        }

        .file-upload-area.dragover {
            border-color: #2a5298;
            background-color: #e8f0ff;
        }

        .search-section {
            margin-bottom: 25px;
        }

        .search-box {
            width: 100%;
            padding: 12px 15px;
            font-size: 16px;
            border: 2px solid #ddd;
            border-radius: 8px;
            transition: border-color 0.3s ease;
        }

        .search-box:focus {
            outline: none;
            border-color: #2a5298;
            box-shadow: 0 0 10px rgba(42, 82, 152, 0.1);
        }

        .form-group {
            margin-bottom: 15px;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #555;
        }

        .form-group select,
        .form-group input {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
        }

        .btn {
            background: linear-gradient(135deg, #2a5298 0%, #1e3c72 100%);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s ease;
            margin: 5px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(42, 82, 152, 0.3);
        }

        .btn-secondary {
            background: linear-gradient(135deg, #6c757d 0%, #495057 100%);
        }

        .btn-success {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
        }

        .btn-danger {
            background: linear-gradient(135deg, #dc3545 0%, #c82333 100%);
        }

        .results-panel {
            grid-column: 1 / -1;
            background: white;
            border-radius: 10px;
            padding: 25px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            border-left: 4px solid #28a745;
            margin-bottom: 20px;
            display: none;
        }

        .results-panel.show {
            display: block;
        }

        .classification {
            display: inline-block;
            padding: 6px 12px;
            border-radius: 20px;
            font-weight: 600;
            font-size: 14px;
            margin: 5px;
        }

        .classification.summary {
            background-color: #d4edda;
            color: #155724;
        }

        .classification.table1 {
            background-color: #cce7ff;
            color: #004085;
        }

        .classification.table2 {
            background-color: #fff3cd;
            color: #856404;
        }

        .classification.indictable {
            background-color: #f8d7da;
            color: #721c24;
        }

        .workflow-timeline {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
        }

        .timeline-item {
            display: flex;
            align-items: flex-start;
            margin-bottom: 15px;
            padding: 10px;
            background: white;
            border-radius: 5px;
            border-left: 3px solid #2a5298;
        }

        .timeline-item .step {
            background: #2a5298;
            color: white;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 15px;
            font-weight: 600;
            flex-shrink: 0;
        }

        .timeline-item .content {
            flex: 1;
        }

        .timeline-item .content h4 {
            margin-bottom: 5px;
            color: #1e3c72;
        }

        .loading {
            text-align: center;
            padding: 20px;
            color: #666;
        }

        .spinner {
            border: 3px solid #f3f3f3;
            border-top: 3px solid #2a5298;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .status-indicator {
            padding: 8px 15px;
            border-radius: 5px;
            margin: 5px 0;
            font-size: 14px;
        }

        .status-success {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .status-error {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .status-warning {
            background-color: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }

        .suggestions-list {
            background: white;
            border: 1px solid #ddd;
            border-top: none;
            border-radius: 0 0 8px 8px;
            max-height: 200px;
            overflow-y: auto;
            position: absolute;
            width: 100%;
            z-index: 1000;
            display: none;
        }

        .suggestion-item {
            padding: 10px 15px;
            cursor: pointer;
            border-bottom: 1px solid #eee;
            transition: background-color 0.2s ease;
        }

        .suggestion-item:hover {
            background-color: #f8f9fa;
        }

        .penalty-info {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
        }

        .penalty-info h4 {
            color: #1e3c72;
            margin-bottom: 10px;
        }

        .documents-checklist {
            background: #fff;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
            border: 1px solid #dee2e6;
        }

        .checklist-item {
            display: flex;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid #eee;
        }

        .checklist-item:last-child {
            border-bottom: none;
        }

        .checklist-item input[type="checkbox"] {
            margin-right: 10px;
        }

        @media (max-width: 768px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }

        .export-options {
            margin-top: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
        }

        .search-position {
            position: relative;
        }

        .cross-references {
            background: #f8f9ff;
            border: 1px solid #e3e8ff;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
        }

        .reference-category {
            margin-bottom: 10px;
        }

        .reference-category ul {
            margin: 5px 0 0 20px;
            padding: 0;
        }

        .reference-category li {
            margin: 3px 0;
            font-size: 14px;
        }

        .classification-reason,
        .charge-value {
            margin: 10px 0;
            padding: 8px 12px;
            background: #f1f3f4;
            border-left: 3px solid #4285f4;
            border-radius: 4px;
            font-size: 14px;
        }

        .analysis-info {
            margin-top: 20px;
            padding-top: 15px;
            border-top: 1px solid #eee;
            text-align: center;
            color: #666;
        }

        .btn-success:hover {
            background: linear-gradient(135deg, #20c997 0%, #17a2b8 100%);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(32, 201, 151, 0.3);
        }

        /* Enhanced workflow display */
        .workflow-timeline .timeline-item .content h4 {
            color: #1e3c72;
            font-size: 16px;
            margin-bottom: 5px;
        }

        .workflow-timeline .timeline-item .content .description {
            color: #666;
            font-size: 13px;
            font-style: italic;
            margin: 5px 0;
        }

        .workflow-timeline .timeline-item.completed {
            opacity: 0.7;
            background: #f8f9fa;
        }

        .workflow-timeline .timeline-item.urgent {
            border-left-color: #dc3545;
            background: #fff5f5;
        }

        .next-actions {
            background: #e8f5e8;
            border: 1px solid #c3e6c3;
            border-radius: 8px;
            padding: 15px;
            margin: 20px 0;
        }

        .next-actions h4 {
            color: #155724;
            margin-bottom: 10px;
        }

        .next-actions ul {
            margin: 0;
            padding-left: 20px;
        }

        .next-actions li {
            margin: 5px 0;
            font-weight: 500;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>NSW Criminal Law Legislative Intelligence System</h1>
            <p>Automated procedural workflows and jurisdiction mapping for NSW criminal legislation</p>
        </div>

        <div class="main-content">
            <!-- File Upload Section -->
            <div class="panel">
                <h2>📁 Legislation Files</h2>
                
                <div class="file-upload-area" id="fileUploadArea">
                    <p><strong>Drop legislation files here or click to browse</strong></p>
                    <p>Upload .txt legislation files (Criminal Procedure Act, Crimes Act, etc.)</p>
                    <input type="file" id="fileInput" multiple accept=".txt" style="display: none;">
                </div>

                <div id="fileStatus"></div>
                
                <div class="form-group">
                    <button class="btn" onclick="loadDefaultFiles()">Load Default Files</button>
                    <button class="btn btn-secondary" onclick="clearFiles()">Clear All</button>
                    <button class="btn btn-success" onclick="validateSystem()">Validate System</button>
                </div>
            </div>

            <!-- Search & Analysis Section -->
            <div class="panel">
                <h2>🔍 Charge Analysis</h2>
                
                <div class="search-section">
                    <div class="search-position">
                        <input type="text" 
                               id="searchBox" 
                               class="search-box" 
                               placeholder="Enter section number (e.g., 61I, s.60, section 117) or charge description..."
                               autocomplete="off">
                        <div id="suggestionsList" class="suggestions-list"></div>
                    </div>
                </div>

                <div class="form-group">
                    <label for="pleaSelect">Plea Status</label>
                    <select id="pleaSelect">
                        <option value="not_entered">No plea entered yet</option>
                        <option value="guilty">Guilty plea</option>
                        <option value="not_guilty">Not guilty plea</option>
                    </select>
                </div>

                <div class="form-group">
                    <label for="courtSelect">Preferred Court</label>
                    <select id="courtSelect">
                        <option value="auto">Auto-determine</option>
                        <option value="local">Local Court</option>
                        <option value="district">District Court</option>
                        <option value="supreme">Supreme Court</option>
                    </select>
                </div>

                <button class="btn" onclick="analyzeCharge()">Analyze Charge</button>
                <button class="btn btn-success" onclick="generateWorkflow()">Generate Workflow</button>
            </div>
        </div>

        <!-- Results Panel -->
        <div id="resultsPanel" class="results-panel">
            <h2>📊 Analysis Results</h2>
            <div id="resultsContent"></div>
        </div>

        <!-- Workflow Panel -->
        <div id="workflowPanel" class="results-panel">
            <h2>📋 Procedural Workflow</h2>
            <div id="workflowContent"></div>
            
            <div class="export-options">
                <h3>Export Options</h3>
                <button class="btn btn-secondary" onclick="exportWorkflow('pdf')">Export as PDF</button>
                <button class="btn btn-secondary" onclick="exportWorkflow('copy')">Copy to Clipboard</button>
                <button class="btn btn-secondary" onclick="exportWorkflow('print')">Print Workflow</button>
            </div>
        </div>
    </div>

    <script>
        // Core Classes
        class LegislativeProcessor {
            constructor() {
                this.sections = new Map();
                this.penalties = new Map();
                this.references = new Map();
                this.sectionTitles = new Map();
                this.acts = new Map();
            }

            async processLegislation(text, actName) {
                console.log(`Processing ${actName}...`);
                
                // Extract all sections with flexible patterns
                const sectionPatterns = [
                    /^\s*(\d+[A-Z]*)\s+([^\n]+?)(?=\n|$)/gm,
                    /(?:section|s\.?)\s*(\d+[A-Z]*)\s*[:\-]?\s*([^\n]+)/gi,
                    /\b(\d+[A-Z]*)\s+([A-Z][^.\n]*?)(?=\s*\n|\s*$)/gm
                ];

                let sectionMatches = [];
                
                // Use multiple patterns to capture sections
                sectionPatterns.forEach(pattern => {
                    let match;
                    while ((match = pattern.exec(text)) !== null) {
                        sectionMatches.push({
                            number: match[1],
                            title: match[2].trim(),
                            index: match.index
                        });
                    }
                });

                // Sort by position in text
                sectionMatches.sort((a, b) => a.index - b.index);

                // Extract section content and penalties
                for (let i = 0; i < sectionMatches.length; i++) {
                    const section = sectionMatches[i];
                    const nextSection = sectionMatches[i + 1];
                    
                    const startIndex = section.index;
                    const endIndex = nextSection ? nextSection.index : text.length;
                    const sectionText = text.substring(startIndex, endIndex);
                    
                    const sectionData = {
                        number: section.number,
                        title: section.title,
                        text: sectionText,
                        act: actName,
                        penalty: this.extractPenalty(sectionText)
                    };

                    this.sections.set(section.number, sectionData);
                    this.sectionTitles.set(section.number, section.title);
                    
                    if (sectionData.penalty) {
                        this.penalties.set(section.number, sectionData.penalty);
                    }
                }

                // Extract cross-references
                this.extractReferences(text, actName);
                
                this.acts.set(actName, {
                    text: text,
                    sectionCount: sectionMatches.length,
                    processed: true
                });

                console.log(`Processed ${sectionMatches.length} sections from ${actName}`);
                return sectionMatches.length;
            }

            extractSection(text, sectionNumber) {
                // Clean section number
                const cleanNumber = sectionNumber.replace(/^s\.?/i, '').trim();
                
                // Try exact match first
                if (this.sections.has(cleanNumber)) {
                    return this.sections.get(cleanNumber);
                }

                // Try alternative formats
                const alternatives = [
                    cleanNumber,
                    cleanNumber.replace(/[A-Z]/g, ''),
                    cleanNumber + 'A',
                    cleanNumber + 'B'
                ];

                for (const alt of alternatives) {
                    if (this.sections.has(alt)) {
                        return this.sections.get(alt);
                    }
                }

                // Search by content
                const contentPattern = new RegExp(`\\b(?:section|s\\.?)\\s*${cleanNumber}\\b`, 'i');
                for (const [key, section] of this.sections) {
                    if (contentPattern.test(section.text) || section.title.includes(cleanNumber)) {
                        return section;
                    }
                }

                return null;
            }

            extractPenalty(sectionText) {
                // Enhanced penalty extraction for ALL NSW formats
                const formats = {
                    // Life imprisonment (highest priority)
                    life: /\blife\s+imprisonment\b/gi,
                    
                    // Standard: "imprisonment for X years"
                    standard: /imprisonment\s+for\s+(?:not\s+more\s+than\s+)?(\d+)\s+(years?|months?)/gi,
                    
                    // Alternative: "X years imprisonment"
                    alternative: /(\d+)\s+(years?|months?)\s+imprisonment/gi,
                    
                    // Penalty units: "50 penalty units"
                    units: /(\d+)\s+penalty\s+units/gi,
                    
                    // Fine formats: "fine of $5,000", "fine not exceeding $10,000"
                    fine: /fine\s+(?:not\s+exceeding\s+|of\s+)?\$?([\d,]+)/gi,
                    
                    // Maximum penalty prefix with various formats
                    maximum: /maximum\s+penalty[:\s]*(.*?)(?=\.|$|\n)/gi,
                    
                    // Penalty in brackets: "(Penalty: 2 years imprisonment)"
                    bracket: /\(penalty[:\s]*(.*?)\)/gi,
                    
                    // NSW specific: "not more than X years"
                    notMoreThan: /not\s+more\s+than\s+(\d+)\s+(years?|months?)/gi,
                    
                    // NSW pecuniary penalties
                    pecuniary: /(\d+)\s+penalty\s+units?\s+or\s+imprisonment\s+for\s+(\d+)\s+(years?|months?)/gi
                };

                let penalty = {
                    years: 0,
                    months: 0,
                    units: 0,
                    fine: 0,
                    life: false,
                    text: '',
                    alternatives: []
                };

                // Check for life imprisonment first
                if (formats.life.test(sectionText)) {
                    penalty.life = true;
                    penalty.years = 999; // For comparison purposes
                    penalty.text = 'Life imprisonment';
                    return penalty;
                }

                // Process each format type
                for (const [formatName, pattern] of Object.entries(formats)) {
                    let match;
                    pattern.lastIndex = 0; // Reset regex
                    
                    while ((match = pattern.exec(sectionText)) !== null) {
                        this.processPenaltyMatch(match, formatName, penalty);
                    }
                }

                // Extract from maximum penalty clauses
                const maxPenaltyMatch = sectionText.match(/maximum\s+penalty[:\s]*(.*?)(?=\.|$|\n)/gi);
                if (maxPenaltyMatch) {
                    maxPenaltyMatch.forEach(clause => {
                        this.extractFromMaximumClause(clause, penalty);
                    });
                }

                // Build penalty text description
                penalty.text = this.buildPenaltyText(penalty);

                return Object.keys(penalty).some(key => penalty[key] && key !== 'text' && key !== 'alternatives') ? penalty : null;
            }

            processPenaltyMatch(match, formatName, penalty) {
                const fullMatch = match[0].toLowerCase();
                
                switch (formatName) {
                    case 'standard':
                    case 'alternative':
                    case 'notMoreThan':
                        const value = parseInt(match[1]);
                        const unit = match[2].toLowerCase();
                        
                        if (unit.includes('year')) {
                            penalty.years = Math.max(penalty.years, value);
                        } else if (unit.includes('month')) {
                            penalty.months = Math.max(penalty.months, value);
                        }
                        break;
                        
                    case 'units':
                        penalty.units = Math.max(penalty.units, parseInt(match[1]));
                        break;
                        
                    case 'fine':
                        const fineAmount = parseInt(match[1].replace(/,/g, ''));
                        penalty.fine = Math.max(penalty.fine, fineAmount);
                        break;
                        
                    case 'pecuniary':
                        // Handle "X penalty units or Y years imprisonment"
                        penalty.units = Math.max(penalty.units, parseInt(match[1]));
                        const impValue = parseInt(match[2]);
                        const impUnit = match[3].toLowerCase();
                        
                        if (impUnit.includes('year')) {
                            penalty.years = Math.max(penalty.years, impValue);
                        } else if (impUnit.includes('month')) {
                            penalty.months = Math.max(penalty.months, impValue);
                        }
                        
                        penalty.alternatives.push({
                            type: 'alternative',
                            units: parseInt(match[1]),
                            imprisonment: { value: impValue, unit: impUnit }
                        });
                        break;
                }
            }

            extractFromMaximumClause(clause, penalty) {
                // Extract penalties from "maximum penalty" clauses
                const yearMatch = clause.match(/(\d+)\s+(years?)/i);
                if (yearMatch) {
                    penalty.years = Math.max(penalty.years, parseInt(yearMatch[1]));
                }

                const monthMatch = clause.match(/(\d+)\s+(months?)/i);
                if (monthMatch) {
                    penalty.months = Math.max(penalty.months, parseInt(monthMatch[1]));
                }

                const unitMatch = clause.match(/(\d+)\s+penalty\s+units?/i);
                if (unitMatch) {
                    penalty.units = Math.max(penalty.units, parseInt(unitMatch[1]));
                }

                const fineMatch = clause.match(/\$?([\d,]+)/);
                if (fineMatch && clause.toLowerCase().includes('fine')) {
                    penalty.fine = Math.max(penalty.fine, parseInt(fineMatch[1].replace(/,/g, '')));
                }
            }

            buildPenaltyText(penalty) {
                const parts = [];
                
                if (penalty.life) {
                    return 'Life imprisonment';
                }
                
                if (penalty.years > 0) {
                    parts.push(`${penalty.years} year${penalty.years > 1 ? 's' : ''} imprisonment`);
                }
                
                if (penalty.months > 0 && penalty.years === 0) {
                    parts.push(`${penalty.months} month${penalty.months > 1 ? 's' : ''} imprisonment`);
                }
                
                if (penalty.units > 0) {
                    parts.push(`${penalty.units} penalty unit${penalty.units > 1 ? 's' : ''}`);
                }
                
                if (penalty.fine > 0) {
                    parts.push(`$${penalty.fine.toLocaleString()} fine`);
                }

                // Handle alternatives
                if (penalty.alternatives.length > 0) {
                    const alt = penalty.alternatives[0];
                    if (alt.type === 'alternative') {
                        return `${alt.units} penalty units or ${alt.imprisonment.value} ${alt.imprisonment.unit} imprisonment`;
                    }
                }
                
                return parts.length > 0 ? parts.join(' or ') : 'Penalty not specified';
            }

            extractReferences(text, actName) {
                const referencePattern = /(?:section|s\.?)\s*(\d+[A-Z]*)/gi;
                let match;
                
                while ((match = referencePattern.exec(text)) !== null) {
                    const sectionNumber = match[1];
                    if (!this.references.has(sectionNumber)) {
                        this.references.set(sectionNumber, new Set());
                    }
                    this.references.get(sectionNumber).add(actName);
                }
            }

            buildSynonymMap() {
                const synonyms = new Map();
                
                for (const [section, title] of this.sectionTitles) {
                    // Extract key terms from titles
                    const terms = title.toLowerCase()
                        .replace(/[^\w\s]/g, ' ')
                        .split(/\s+/)
                        .filter(term => term.length > 3);
                    
                    terms.forEach(term => {
                        if (!synonyms.has(term)) {
                            synonyms.set(term, new Set());
                        }
                        synonyms.get(term).add(section);
                    });
                }
                
                return synonyms;
            }
        }

        class ScheduleClassifier {
            constructor() {
                this.table1 = new Set();
                this.table2 = new Set();
                this.table1Details = new Map();
                this.table2Details = new Map();
                this.strictlyIndictable = new Set();
                this.specialCases = new Map();
            }

            parseSchedule1(scheduleText) {
                console.log('Parsing Schedule 1 with enhanced logic...');
                
                // CRITICAL: Extract tables by their exact text boundaries
                const table1Start = scheduleText.indexOf('Table 1 - Indictable offences that are to be dealt with summarily unless prosecutor or person charged elects otherwise');
                const table1End = scheduleText.indexOf('Table 2 - Indictable offences that are to be dealt with summarily unless prosecutor elects otherwise');
                
                if (table1Start !== -1 && table1End !== -1) {
                    const table1Text = scheduleText.substring(table1Start, table1End);
                    this.extractSectionsFromTable(table1Text, 'Table 1');
                }

                // Extract Table 2
                const table2Start = table1End;
                const table2End = scheduleText.indexOf('Schedule 2') !== -1 ? 
                    scheduleText.indexOf('Schedule 2') : scheduleText.length;
                
                if (table2Start !== -1) {
                    const table2Text = scheduleText.substring(table2Start, table2End);
                    this.extractSectionsFromTable(table2Text, 'Table 2');
                }

                console.log(`Enhanced parsing: Table 1: ${this.table1.size} entries, Table 2: ${this.table2.size} entries`);
                this.logParsedSections();
            }

            extractSectionsFromTable(tableText, tableName) {
                // Enhanced patterns to catch all section reference formats
                const patterns = [
                    // Basic: "section 60", "under section 61E"
                    /(?:under\s+)?section\s+(\d+[A-Z]*)/gi,
                    
                    // Multiple sections: "sections 33, 35, 35A"
                    /sections\s+([\d\w,\s]+?)(?=\s+of|where|\.|$)/gi,
                    
                    // With subsections: "60 (2) or (2A)", "61E, 66C (1)"
                    /(\d+[A-Z]*)\s*(?:\([^)]+\))?/g,
                    
                    // In offense descriptions: "An offence under section 61I"
                    /An\s+offence\s+under\s+section\s+(\d+[A-Z]*)/gi,
                    
                    // Ranges: "154A, 154B, 154C" or "sections 178A-178C"
                    /sections?\s+(\d+[A-Z]?)\s*[-–]\s*(\d+[A-Z]?)/gi
                ];

                const targetSet = tableName === 'Table 1' ? this.table1 : this.table2;
                const targetMap = tableName === 'Table 1' ? this.table1Details : this.table2Details;

                // Extract all section patterns
                patterns.forEach((pattern, patternIndex) => {
                    let match;
                    pattern.lastIndex = 0; // Reset regex
                    
                    while ((match = pattern.exec(tableText)) !== null) {
                        if (patternIndex === 1) { // Multiple sections pattern
                            // Handle comma-separated sections
                            const sections = match[1].split(/[,\s]+/).filter(s => /\d/.test(s));
                            sections.forEach(section => {
                                const cleanSection = section.replace(/[^\d\w]/g, '');
                                if (cleanSection) {
                                    this.addSectionToTable(cleanSection, targetSet, targetMap, tableText, match.index, tableName);
                                }
                            });
                        } else if (patternIndex === 4) { // Range pattern
                            // Handle section ranges like "178A-178C"
                            const startSection = match[1];
                            const endSection = match[2];
                            // Add logic to expand ranges
                            this.expandSectionRange(startSection, endSection, targetSet, targetMap, tableText, match.index, tableName);
                        } else {
                            // Single section
                            const section = match[1];
                            if (section) {
                                this.addSectionToTable(section, targetSet, targetMap, tableText, match.index, tableName);
                            }
                        }
                    }
                });

                // Special handling for specific NSW patterns
                this.handleSpecialNSWPatterns(tableText, targetSet, targetMap, tableName);
            }

            addSectionToTable(section, targetSet, targetMap, fullText, index, tableName) {
                const cleanSection = section.trim();
                targetSet.add(cleanSection);
                
                // Extract context and conditions
                const context = this.extractSectionContext(fullText, index);
                const valueThreshold = this.extractValueThreshold(context);
                const conditions = this.extractConditions(context);
                
                targetMap.set(cleanSection, {
                    table: tableName,
                    context: context,
                    valueThreshold: valueThreshold,
                    conditions: conditions,
                    originalText: fullText.substring(Math.max(0, index - 100), index + 100)
                });

                // Handle subsection variations
                this.handleSubsectionVariations(cleanSection, targetSet, targetMap, context, tableName);
            }

            handleSubsectionVariations(baseSection, targetSet, targetMap, context, tableName) {
                // Handle patterns like "60 (2) or (2A)" - add both forms
                const subsectionMatch = context.match(new RegExp(`${baseSection}\\s*\\(([^)]+)\\)`, 'g'));
                if (subsectionMatch) {
                    subsectionMatch.forEach(match => {
                        const fullMatch = match.match(/(\d+[A-Z]*)\s*\(([^)]+)\)/);
                        if (fullMatch) {
                            const base = fullMatch[1];
                            const subs = fullMatch[2].split(/\s*(?:or|,)\s*/);
                            
                            subs.forEach(sub => {
                                const fullSection = `${base}(${sub.trim()})`;
                                targetSet.add(fullSection);
                                targetSet.add(base); // Also add base section
                            });
                        }
                    });
                }
            }

            expandSectionRange(start, end, targetSet, targetMap, fullText, index, tableName) {
                // Expand ranges like 178A-178C to individual sections
                const startNum = parseInt(start.replace(/[A-Z]/g, ''));
                const endNum = parseInt(end.replace(/[A-Z]/g, ''));
                const startLetter = start.match(/[A-Z]/)?.[0] || '';
                const endLetter = end.match(/[A-Z]/)?.[0] || '';

                if (startNum === endNum && startLetter && endLetter) {
                    // Letter range within same number (e.g., 178A-178C)
                    const startCode = startLetter.charCodeAt(0);
                    const endCode = endLetter.charCodeAt(0);
                    
                    for (let code = startCode; code <= endCode; code++) {
                        const section = startNum + String.fromCharCode(code);
                        this.addSectionToTable(section, targetSet, targetMap, fullText, index, tableName);
                    }
                } else {
                    // Number range
                    for (let num = startNum; num <= endNum; num++) {
                        this.addSectionToTable(num.toString(), targetSet, targetMap, fullText, index, tableName);
                    }
                }
            }

            handleSpecialNSWPatterns(tableText, targetSet, targetMap, tableName) {
                // Handle NSW-specific patterns that might be missed by general regex
                
                // Pattern: "larceny" references without explicit section numbers
                if (tableText.includes('larceny') || tableText.includes('Larceny')) {
                    // Larceny is typically s.117 Crimes Act
                    this.addSectionToTable('117', targetSet, targetMap, tableText, 0, tableName);
                }

                // Pattern: "fraud and related offences" 
                if (tableText.includes('Fraud and related offences')) {
                    // Part 4AA Crimes Act - sections 178A onwards
                    const fraudSections = ['178A', '178B', '178BA', '178BB', '178C'];
                    fraudSections.forEach(section => {
                        this.addSectionToTable(section, targetSet, targetMap, tableText, 0, tableName);
                    });
                }

                // Pattern: Value-based conditions for property offences
                const valuePatterns = [
                    /exceeding\s+\$(\d+(?:,\d{3})*)/gi,
                    /not\s+exceed\s+\$(\d+(?:,\d{3})*)/gi,
                    /does\s+not\s+exceed\s+\$(\d+(?:,\d{3})*)/gi
                ];

                valuePatterns.forEach(pattern => {
                    let match;
                    while ((match = pattern.exec(tableText)) !== null) {
                        const threshold = parseInt(match[1].replace(/,/g, ''));
                        // Store this threshold for property offense classification
                        if (threshold === 5000) {
                            this.specialCases.set('property_threshold', threshold);
                        }
                    }
                });
            }

            extractConditions(context) {
                const conditions = [];
                
                // Value conditions
                if (context.includes('exceeding')) {
                    const match = context.match(/exceeding\s+\$(\d+(?:,\d{3})*)/i);
                    if (match) {
                        conditions.push({
                            type: 'value_exceeds',
                            amount: parseInt(match[1].replace(/,/g, ''))
                        });
                    }
                }

                if (context.includes('does not exceed')) {
                    const match = context.match(/does\s+not\s+exceed\s+\$(\d+(?:,\d{3})*)/i);
                    if (match) {
                        conditions.push({
                            type: 'value_under',
                            amount: parseInt(match[1].replace(/,/g, ''))
                        });
                    }
                }

                // Age conditions
                if (context.includes('14 years')) {
                    conditions.push({
                        type: 'victim_age',
                        minimum: 14
                    });
                }

                // Death exclusions
                if (context.includes('death was occasioned')) {
                    conditions.push({
                        type: 'exclude_death'
                    });
                }

                return conditions;
            }

            logParsedSections() {
                console.log('Table 1 sections:', Array.from(this.table1).sort());
                console.log('Table 2 sections:', Array.from(this.table2).sort());
                
                // Log some examples with conditions
                for (const [section, details] of this.table1Details) {
                    if (details.conditions.length > 0) {
                        console.log(`Table 1 - Section ${section}:`, details.conditions);
                        break; // Just show one example
                    }
                }
            }

            extractSectionContext(text, index) {
                const start = Math.max(0, index - 200);
                const end = Math.min(text.length, index + 200);
                return text.substring(start, end).trim();
            }

            extractValueThreshold(context) {
                const valueMatch = context.match(/\$(\d+(?:,\d{3})*)/);
                return valueMatch ? parseInt(valueMatch[1].replace(/,/g, '')) : null;
            }

            classifyOffence(sectionNumber, penaltyData, chargeValue = null, chargeContext = {}) {
                // STEP 1: Clean section number for comparison
                const cleanSection = sectionNumber.replace(/^s\.?/i, '').trim();
                
                console.log(`Classifying section ${cleanSection}, value: ${chargeValue}, penalty:`, penaltyData);
                
                // STEP 2: Check Table 1 first (dual election)
                if (this.table1.has(cleanSection)) {
                    const details = this.table1Details.get(cleanSection);
                    
                    // Check for value-based classification changes
                    if (details && details.conditions) {
                        for (const condition of details.conditions) {
                            if (condition.type === 'value_under' && chargeValue !== null) {
                                if (chargeValue < condition.amount) {
                                    return {
                                        classification: 'Table 2',
                                        court: 'Local Court (unless prosecution elects)',
                                        election: 'Only prosecution can elect District Court',
                                        reason: `Value $${chargeValue.toLocaleString()} is under Table 1 threshold of $${condition.amount.toLocaleString()}`,
                                        originalTable: 'Table 1'
                                    };
                                }
                            }
                            
                            if (condition.type === 'value_exceeds' && chargeValue !== null) {
                                if (chargeValue < condition.amount) {
                                    return {
                                        classification: 'Summary Only',
                                        court: 'Local Court',
                                        election: 'No election available',
                                        reason: `Value $${chargeValue.toLocaleString()} does not meet Table 1 minimum of $${condition.amount.toLocaleString()}`
                                    };
                                }
                            }
                            
                            // Handle death exclusions
                            if (condition.type === 'exclude_death' && chargeContext.death === true) {
                                return {
                                    classification: 'Strictly Indictable',
                                    court: 'District/Supreme Court',
                                    election: 'Must proceed on indictment',
                                    reason: 'Death was occasioned - excluded from Table 1'
                                };
                            }
                        }
                    }
                    
                    return {
                        classification: 'Table 1',
                        court: 'Local Court (unless elected)',
                        election: 'Either prosecution or defendant can elect District Court',
                        briefService: '6 weeks from first appearance',
                        electionPeriod: '28 days'
                    };
                }

                // STEP 3: Check Table 2 (prosecution election only)
                if (this.table2.has(cleanSection)) {
                    const details = this.table2Details.get(cleanSection);
                    
                    // Check Table 2 specific conditions
                    if (details && details.conditions) {
                        for (const condition of details.conditions) {
                            if (condition.type === 'value_exceeds' && chargeValue !== null) {
                                if (chargeValue >= condition.amount) {
                                    return {
                                        classification: 'Table 1',
                                        court: 'Local Court (unless elected)',
                                        election: 'Either party can elect District Court',
                                        reason: `Value $${chargeValue.toLocaleString()} exceeds Table 2 threshold - promoted to Table 1`
                                    };
                                }
                            }
                        }
                    }
                    
                    return {
                        classification: 'Table 2',
                        court: 'Local Court (unless prosecution elects)',
                        election: 'Only prosecution can elect District Court',
                        briefService: '6 weeks from first appearance if defended'
                    };
                }

                // STEP 4: Not in Schedule 1 tables - use penalty analysis
                if (penaltyData) {
                    const maxPenaltyYears = this.calculateMaxPenalty(penaltyData);
                    
                    // Life imprisonment = strictly indictable
                    if (penaltyData.life) {
                        return {
                            classification: 'Strictly Indictable',
                            court: 'Supreme Court (life imprisonment)',
                            election: 'Must proceed on indictment',
                            reason: 'Life imprisonment penalty'
                        };
                    }
                    
                    // More than 2 years max penalty = strictly indictable
                    if (maxPenaltyYears > 2) {
                        const court = maxPenaltyYears >= 7 ? 'District/Supreme Court' : 'District Court';
                        return {
                            classification: 'Strictly Indictable',
                            court: court,
                            election: 'Must proceed on indictment',
                            reason: `Maximum penalty of ${maxPenaltyYears} years exceeds 2-year summary limit`,
                            committalRequired: true
                        };
                    }
                    
                    // 2 years or less = summary only
                    return {
                        classification: 'Summary Only',
                        court: 'Local Court',
                        election: 'No election available',
                        reason: `Maximum penalty of ${maxPenaltyYears} years ≤ 2-year summary limit`
                    };
                }

                // STEP 5: No penalty data available - conservative approach
                return {
                    classification: 'Unknown - Analysis Required',
                    court: 'To be determined',
                    election: 'Requires further analysis',
                    reason: 'Section not in Schedule 1 and no penalty data available',
                    action: 'Check penalty provisions in Crimes Act'
                };
            }

            calculateMaxPenalty(penalty) {
                if (!penalty) return 0;
                
                let totalYears = 0;
                
                if (penalty.life) return 999; // Life imprisonment
                if (penalty.years) totalYears += penalty.years;
                if (penalty.months) totalYears += penalty.months / 12;
                
                // Convert penalty units to equivalent imprisonment (rough approximation)
                if (penalty.units && !totalYears) {
                    // Generally, higher penalty units indicate more serious offenses
                    // This is a rough guide - actual conversion varies
                    if (penalty.units > 200) totalYears = 2;
                    else if (penalty.units > 100) totalYears = 1;
                    else if (penalty.units > 50) totalYears = 0.5;
                }
                
                return totalYears;
            }

            // Validation method for known test cases
            validateClassification() {
                const testCases = [
                    // Table 1 tests
                    { section: '61I', expected: 'Table 1', description: 'Sexual assault - Table 1' },
                    { section: '60', expected: 'Table 1', description: 'Assault police - Table 1' },
                    
                    // Table 2 tests  
                    { section: '117', expected: 'Table 2', value: 1000, description: 'Larceny under $5000' },
                    { section: '61', expected: 'Table 2', description: 'Common assault - Table 2' },
                    
                    // Value threshold tests
                    { section: '117', expected: 'Table 1', value: 10000, description: 'Larceny over $5000' },
                    
                    // Penalty-based tests
                    { section: '19A', expected: 'Strictly Indictable', description: 'Murder (life imprisonment)' }
                ];

                console.log('Running classification validation tests...');
                testCases.forEach(test => {
                    const mockPenalty = test.section === '19A' ? { life: true } : { years: 1 };
                    const result = this.classifyOffence(test.section, mockPenalty, test.value);
                    
                    const passed = result.classification.includes(test.expected);
                    console.log(`${passed ? '✓' : '✗'} ${test.description}: Expected ${test.expected}, got ${result.classification}`);
                });
            }

            calculateMaxPenalty(penalty) {
                let years = 0;
                if (penalty.years) years += penalty.years;
                if (penalty.months) years += penalty.months / 12;
                return years;
            }
        }

        class LegalSearch {
            constructor() {
                this.searchIndex = new Map();
                this.conceptMap = new Map();
                this.synonyms = new Map();
            }

            buildSearchIndex(processor) {
                console.log('Building search index...');
                
                // Index all sections
                for (const [sectionNumber, sectionData] of processor.sections) {
                    const searchableText = [
                        sectionNumber,
                        sectionData.title,
                        sectionData.text
                    ].join(' ').toLowerCase();

                    // Create searchable terms
                    const terms = searchableText
                        .replace(/[^\w\s]/g, ' ')
                        .split(/\s+/)
                        .filter(term => term.length > 2);

                    terms.forEach(term => {
                        if (!this.searchIndex.has(term)) {
                            this.searchIndex.set(term, new Set());
                        }
                        this.searchIndex.get(term).add(sectionNumber);
                    });

                    // Index by section number patterns
                    const sectionPatterns = [
                        sectionNumber,
                        `s${sectionNumber}`,
                        `s.${sectionNumber}`,
                        `section${sectionNumber}`,
                        `section ${sectionNumber}`
                    ];

                    sectionPatterns.forEach(pattern => {
                        this.searchIndex.set(pattern.toLowerCase(), new Set([sectionNumber]));
                    });
                }

                this.buildConceptMap(processor);
            }

            buildConceptMap(processor) {
                // Build concept relationships
                const concepts = {
                    'assault': ['60', '59', '61', '58'],
                    'sexual': ['61I', '61J', '61KC', '61KD'],
                    'theft': ['117', '118', '119', '125'],
                    'fraud': ['178', '179', '180'],
                    'drug': ['25', '25A', '25B'],
                    'traffic': ['52A', '52B', '53'],
                    'weapon': ['33B', '93', '94'],
                    'domestic': ['13', '14', '54D']
                };

                for (const [concept, sections] of Object.entries(concepts)) {
                    this.conceptMap.set(concept, new Set(sections));
                }
            }

            search(query) {
                const results = new Set();
                const searchTerms = query.toLowerCase()
                    .replace(/[^\w\s]/g, ' ')
                    .split(/\s+/)
                    .filter(term => term.length > 1);

                // Direct section number search
                const sectionMatch = query.match(/\b(\d+[A-Z]*)\b/);
                if (sectionMatch) {
                    const section = sectionMatch[1];
                    if (this.searchIndex.has(section.toLowerCase())) {
                        this.searchIndex.get(section.toLowerCase()).forEach(sec => results.add(sec));
                    }
                }

                // Term-based search
                searchTerms.forEach(term => {
                    if (this.searchIndex.has(term)) {
                        this.searchIndex.get(term).forEach(section => results.add(section));
                    }
                });

                // Concept search
                searchTerms.forEach(term => {
                    if (this.conceptMap.has(term)) {
                        this.conceptMap.get(term).forEach(section => results.add(section));
                    }
                });

                return Array.from(results);
            }

            getSuggestions(query) {
                if (query.length < 2) return [];

                const suggestions = [];
                const queryLower = query.toLowerCase();

                // Section number suggestions
                const sectionPattern = /\d+[A-Z]*/;
                if (sectionPattern.test(query)) {
                    for (const [section, data] of legislativeSystem.processor.sections) {
                        if (section.toLowerCase().includes(queryLower)) {
                            suggestions.push({
                                type: 'section',
                                text: `Section ${section} - ${data.title}`,
                                value: section
                            });
                        }
                    }
                }

                // Title-based suggestions
                for (const [section, title] of legislativeSystem.processor.sectionTitles) {
                    if (title.toLowerCase().includes(queryLower)) {
                        suggestions.push({
                            type: 'title',
                            text: `${title} (s.${section})`,
                            value: section
                        });
                    }
                }

                return suggestions.slice(0, 10);
            }
        }

        class WorkflowEngine {
            constructor() {
                this.procedureTemplates = new Map();
                this.initializeTemplates();
            }

            initializeTemplates() {
                // Summary procedure template
                this.procedureTemplates.set('summary', {
                    guilty: [
                        { step: 1, task: 'First appearance in Local Court', deadline: 'Initial court date', mandatory: true },
                        { step: 2, task: 'Enter guilty plea', deadline: 'Same day', mandatory: true },
                        { step: 3, task: 'Facts read by prosecution', deadline: 'Same day', mandatory: true },
                        { step: 4, task: 'Submissions on penalty', deadline: 'Same day', mandatory: true },
                        { step: 5, task: 'Sentence imposed', deadline: 'Same day or adjourned', mandatory: true }
                    ],
                    not_guilty: [
                        { step: 1, task: 'First appearance in Local Court', deadline: 'Initial court date', mandatory: true },
                        { step: 2, task: 'Enter not guilty plea', deadline: 'Same day', mandatory: true },
                        { step: 3, task: 'Request/receive brief of evidence', deadline: '4 weeks', mandatory: true },
                        { step: 4, task: 'Review brief and prepare defence', deadline: '8 weeks', mandatory: true },
                        { step: 5, task: 'Hearing date listed', deadline: '12-16 weeks', mandatory: true },
                        { step: 6, task: 'Local Court hearing', deadline: 'As listed', mandatory: true }
                    ]
                });

                // Table 1 procedure template
                this.procedureTemplates.set('table1', {
                    guilty: [
                        { step: 1, task: 'First appearance in Local Court', deadline: 'Initial court date', mandatory: true },
                        { step: 2, task: 'Consider election rights', deadline: 'Same day', mandatory: true },
                        { step: 3, task: 'Enter guilty plea (if no election)', deadline: 'Same day or adjourned', mandatory: true },
                        { step: 4, task: 'Sentence in Local Court or committal for sentence', deadline: 'Same day or adjourned', mandatory: true }
                    ],
                    not_guilty: [
                        { step: 1, task: 'First appearance in Local Court', deadline: 'Initial court date', mandatory: true },
                        { step: 2, task: 'Consider election rights', deadline: 'Before plea', mandatory: true },
                        { step: 3, task: 'Make election decision (if any)', deadline: 'Within time allowed', mandatory: false },
                        { step: 4, task: 'Enter not guilty plea', deadline: 'After election period', mandatory: true },
                        { step: 5, task: 'Brief of evidence served', deadline: '6 weeks', mandatory: true },
                        { step: 6, task: 'Defence preparation', deadline: '10 weeks', mandatory: true },
                        { step: 7, task: 'Hearing (Local Court or committal)', deadline: '16-20 weeks', mandatory: true }
                    ]
                });

                // Table 2 procedure template
                this.procedureTemplates.set('table2', {
                    guilty: [
                        { step: 1, task: 'First appearance in Local Court', deadline: 'Initial court date', mandatory: true },
                        { step: 2, task: 'Prosecution considers election', deadline: 'Before plea', mandatory: true },
                        { step: 3, task: 'Enter guilty plea (if no election)', deadline: 'Same day or adjourned', mandatory: true },
                        { step: 4, task: 'Sentence in Local Court', deadline: 'Same day or adjourned', mandatory: true }
                    ],
                    not_guilty: [
                        { step: 1, task: 'First appearance in Local Court', deadline: 'Initial court date', mandatory: true },
                        { step: 2, task: 'Prosecution election period', deadline: 'Within time allowed', mandatory: true },
                        { step: 3, task: 'Enter not guilty plea', deadline: 'After election period', mandatory: true },
                        { step: 4, task: 'Brief of evidence served', deadline: '6 weeks', mandatory: true },
                        { step: 5, task: 'Defence preparation', deadline: '10 weeks', mandatory: true },
                        { step: 6, task: 'Hearing in Local Court', deadline: '16-20 weeks', mandatory: true }
                    ]
                });

                // Indictable procedure template
                this.procedureTemplates.set('indictable', {
                    guilty: [
                        { step: 1, task: 'First appearance in Local Court', deadline: 'Initial court date', mandatory: true },
                        { step: 2, task: 'Committal proceedings', deadline: '8-12 weeks', mandatory: true },
                        { step: 3, task: 'Committal for sentence', deadline: 'After committal', mandatory: true },
                        { step: 4, task: 'Sentence in higher court', deadline: '4-8 weeks after committal', mandatory: true }
                    ],
                    not_guilty: [
                        { step: 1, task: 'First appearance in Local Court', deadline: 'Initial court date', mandatory: true },
                        { step: 2, task: 'Brief of evidence served', deadline: '6 weeks', mandatory: true },
                        { step: 3, task: 'Case conference (if required)', deadline: '8 weeks', mandatory: false },
                        { step: 4, task: 'Committal proceedings', deadline: '12-16 weeks', mandatory: true },
                        { step: 5, task: 'Committal for trial', deadline: 'If case to answer', mandatory: true },
                        { step: 6, task: 'Trial preparation', deadline: '12-20 weeks', mandatory: true },
                        { step: 7, task: 'Trial in higher court', deadline: 'As listed', mandatory: true }
                    ]
                });
            }

            generateWorkflow(chargeInfo, plea, electionMade = false, chargeValue = null) {
                console.log('Generating workflow for:', chargeInfo.classification, plea, electionMade ? 'election made' : 'no election');
                
                // Determine workflow type based on classification
                const workflowType = this.determineWorkflowType(chargeInfo.classification);
                
                // Generate base steps
                let steps = this.generateStepsByClassification(workflowType, plea, electionMade, chargeInfo);
                
                // Calculate deadlines
                steps = steps.map(step => ({
                    ...step,
                    deadline: this.calculateDeadline(step.deadline, step.baseDate || 'first_appearance'),
                    completed: false
                }));

                // Generate documents and deadlines
                const documents = this.generateDocumentList(workflowType, plea, electionMade, chargeInfo);
                const keyDeadlines = this.calculateKeyDeadlines(chargeInfo.classification, plea, electionMade);
                const practiceNotes = this.generatePracticeNotes(chargeInfo, plea, electionMade, chargeValue);

                const workflow = {
                    classification: chargeInfo.classification,
                    plea: plea,
                    court: chargeInfo.court,
                    electionMade: electionMade,
                    electionAvailable: this.isElectionAvailable(chargeInfo.classification),
                    steps: steps,
                    documents: documents,
                    keyDeadlines: keyDeadlines,
                    briefService: this.calculateBriefService(chargeInfo.classification, plea, electionMade),
                    notes: practiceNotes,
                    nextActions: this.generateNextActions(steps)
                };

                return workflow;
            }

            determineWorkflowType(classification) {
                if (classification.includes('Table 1')) return 'table1';
                if (classification.includes('Table 2')) return 'table2';
                if (classification.includes('Strictly Indictable')) return 'strictly_indictable';
                if (classification.includes('Summary')) return 'summary';
                return 'unknown';
            }

            generateStepsByClassification(workflowType, plea, electionMade, chargeInfo) {
                const baseSteps = {
                    table1: {
                        guilty: {
                            no_election: [
                                { step: 1, task: 'First appearance in Local Court', deadline: 'court_date', mandatory: true, description: 'Appear before Magistrate, confirm identity and charge' },
                                { step: 2, task: 'Election period expires (no election made)', deadline: '+28 days', mandatory: true, description: '28-day election period for defendant or prosecution expires' },
                                { step: 3, task: 'Enter guilty plea', deadline: 'same_day', mandatory: true, description: 'Enter plea after election period or if no election intended' },
                                { step: 4, task: 'Facts tendered by prosecution', deadline: 'same_day', mandatory: true, description: 'Prosecution reads agreed facts or provides evidence' },
                                { step: 5, task: 'Submissions on penalty', deadline: 'same_day', mandatory: true, description: 'Defence submissions on penalty, character references' },
                                { step: 6, task: 'Sentence imposed by Local Court', deadline: 'same_day', mandatory: true, description: 'Magistrate imposes sentence within Local Court jurisdiction' }
                            ],
                            election_made: [
                                { step: 1, task: 'First appearance in Local Court', deadline: 'court_date', mandatory: true, description: 'Appear before Magistrate, confirm identity and charge' },
                                { step: 2, task: 'Election made for District Court', deadline: '+28 days', mandatory: true, description: 'Either prosecution or defendant elects District Court' },
                                { step: 3, task: 'Committal for sentence', deadline: '+6 weeks', mandatory: true, description: 'Matter committed to District Court for sentence' },
                                { step: 4, task: 'First appearance District Court', deadline: '+10 weeks', mandatory: true, description: 'Arraignment and plea in District Court' },
                                { step: 5, task: 'Sentence in District Court', deadline: 'same_day', mandatory: true, description: 'District Court Judge imposes sentence' }
                            ]
                        },
                        not_guilty: {
                            no_election: [
                                { step: 1, task: 'First appearance in Local Court', deadline: 'court_date', mandatory: true, description: 'Appear before Magistrate, confirm charge and election rights' },
                                { step: 2, task: 'Election period (28 days)', deadline: '+28 days', mandatory: false, description: 'Period for either party to elect District Court - no election means Local Court' },
                                { step: 3, task: 'Enter not guilty plea', deadline: '+35 days', mandatory: true, description: 'Enter plea after election period expires' },
                                { step: 4, task: 'Prosecution serves brief of evidence', deadline: '+42 days', mandatory: true, description: 'Full brief served within 6 weeks of first mention' },
                                { step: 5, task: 'Pre-trial conference (if required)', deadline: '+10 weeks', mandatory: false, description: 'Case conference to discuss issues and possible resolution' },
                                { step: 6, task: 'Local Court hearing/trial', deadline: '+16 weeks', mandatory: true, description: 'Defended hearing before Magistrate' },
                                { step: 7, task: 'Verdict and sentence (if guilty)', deadline: 'same_day', mandatory: true, description: 'Magistrate determines guilt and imposes sentence if convicted' }
                            ],
                            election_made: [
                                { step: 1, task: 'First appearance in Local Court', deadline: 'court_date', mandatory: true, description: 'Appear before Magistrate, confirm charge and election rights' },
                                { step: 2, task: 'Election made for District Court', deadline: '+28 days', mandatory: true, description: 'Either prosecution or defendant elects District Court jurisdiction' },
                                { step: 3, task: 'Brief of evidence served', deadline: '+42 days', mandatory: true, description: 'Full prosecution brief including all witness statements' },
                                { step: 4, task: 'Case conference (if applicable)', deadline: '+8 weeks', mandatory: false, description: 'Mandatory case conference for some indictable matters' },
                                { step: 5, task: 'Committal proceedings', deadline: '+12 weeks', mandatory: true, description: 'Committal hearing to determine if case proceeds to trial' },
                                { step: 6, task: 'Committal for trial (if case to answer)', deadline: 'same_day', mandatory: true, description: 'If prima facie case, committed for trial in District Court' },
                                { step: 7, task: 'Arraignment in District Court', deadline: '+16 weeks', mandatory: true, description: 'Formal arraignment and plea before District Court Judge' },
                                { step: 8, task: 'Trial preparation and mentions', deadline: '+20 weeks', mandatory: true, description: 'Pre-trial case management and preparation' },
                                { step: 9, task: 'District Court trial', deadline: '+24 weeks', mandatory: true, description: 'Trial before Judge and jury (or Judge alone if elected)' }
                            ]
                        }
                    },
                    
                    table2: {
                        guilty: {
                            no_election: [
                                { step: 1, task: 'First appearance in Local Court', deadline: 'court_date', mandatory: true, description: 'Appear before Magistrate, prosecution considers election' },
                                { step: 2, task: 'Prosecution election period expires', deadline: '+28 days', mandatory: true, description: 'Only prosecution can elect - if no election, stays in Local Court' },
                                { step: 3, task: 'Enter guilty plea', deadline: 'same_day', mandatory: true, description: 'Enter plea in Local Court after election period' },
                                { step: 4, task: 'Sentence in Local Court', deadline: 'same_day', mandatory: true, description: 'Magistrate imposes sentence within summary jurisdiction' }
                            ],
                            election_made: [
                                { step: 1, task: 'First appearance in Local Court', deadline: 'court_date', mandatory: true, description: 'Appear before Magistrate' },
                                { step: 2, task: 'Prosecution elects District Court', deadline: '+28 days', mandatory: true, description: 'Only prosecution can elect for Table 2 offences' },
                                { step: 3, task: 'Committal for sentence', deadline: '+6 weeks', mandatory: true, description: 'Committed to District Court for sentence' },
                                { step: 4, task: 'Sentence in District Court', deadline: '+10 weeks', mandatory: true, description: 'District Court Judge imposes sentence' }
                            ]
                        },
                        not_guilty: {
                            no_election: [
                                { step: 1, task: 'First appearance in Local Court', deadline: 'court_date', mandatory: true, description: 'Appear before Magistrate, prosecution considers election' },
                                { step: 2, task: 'Prosecution election period', deadline: '+28 days', mandatory: true, description: 'Only prosecution can elect District Court for Table 2' },
                                { step: 3, task: 'Enter not guilty plea', deadline: '+35 days', mandatory: true, description: 'Enter plea after prosecution election period' },
                                { step: 4, task: 'Brief of evidence served (if defended)', deadline: '+42 days', mandatory: true, description: 'Brief served if matter defended' },
                                { step: 5, task: 'Local Court hearing', deadline: '+12 weeks', mandatory: true, description: 'Defended hearing in Local Court' },
                                { step: 6, task: 'Verdict and sentence', deadline: 'same_day', mandatory: true, description: 'Magistrate determines outcome' }
                            ],
                            election_made: [
                                { step: 1, task: 'First appearance in Local Court', deadline: 'court_date', mandatory: true, description: 'Appear before Magistrate' },
                                { step: 2, task: 'Prosecution elects District Court', deadline: '+28 days', mandatory: true, description: 'Prosecution elects for indictable procedure' },
                                { step: 3, task: 'Brief of evidence served', deadline: '+42 days', mandatory: true, description: 'Full brief for committal proceedings' },
                                { step: 4, task: 'Committal proceedings', deadline: '+12 weeks', mandatory: true, description: 'Committal hearing before Magistrate' },
                                { step: 5, task: 'Trial in District Court (if committed)', deadline: '+20 weeks', mandatory: true, description: 'Trial before District Court if committed' }
                            ]
                        }
                    },

                    strictly_indictable: {
                        any: [
                            { step: 1, task: 'First appearance in Local Court', deadline: 'court_date', mandatory: true, description: 'First mention - cannot be dealt with summarily' },
                            { step: 2, task: 'Brief of evidence served', deadline: '+42 days', mandatory: true, description: 'Full brief must be served for committal' },
                            { step: 3, task: 'Case conference (if required)', deadline: '+8 weeks', mandatory: false, description: 'May be required for complex matters' },
                            { step: 4, task: 'Committal proceedings', deadline: '+12 weeks', mandatory: true, description: 'Committal hearing before Magistrate - mandatory' },
                            { step: 5, task: 'Committal determination', deadline: 'same_day', mandatory: true, description: 'Magistrate determines if case proceeds to higher court' },
                            { step: 6, task: 'Arraignment in higher court', deadline: '+16 weeks', mandatory: true, description: 'Arraignment in District or Supreme Court' },
                            { step: 7, task: 'Trial preparation', deadline: '+20 weeks', mandatory: true, description: 'Pre-trial case management and disclosure' },
                            { step: 8, task: 'Trial in higher court', deadline: '+26 weeks', mandatory: true, description: 'Trial before Judge (and jury for indictable matters)' }
                        ]
                    },

                    summary: {
                        any: [
                            { step: 1, task: 'First appearance in Local Court', deadline: 'court_date', mandatory: true, description: 'Appear before Magistrate for summary matter' },
                            { step: 2, task: 'Enter plea', deadline: 'same_day', mandatory: true, description: 'Enter guilty or not guilty plea' },
                            { step: 3, task: 'Brief on request (if not guilty)', deadline: '+28 days', mandatory: false, description: 'Prosecution brief served if matter defended' },
                            { step: 4, task: 'Hearing (if not guilty)', deadline: '+8 weeks', mandatory: false, description: 'Defended hearing if not guilty plea entered' },
                            { step: 5, task: 'Sentence (if guilty/convicted)', deadline: 'same_day', mandatory: true, description: 'Sentence imposed by Magistrate' }
                        ]
                    }
                };

                const pathKey = plea === 'guilty' ? 'guilty' : 'not_guilty';
                const electionKey = electionMade ? 'election_made' : 'no_election';
                
                if (workflowType === 'strictly_indictable' || workflowType === 'summary') {
                    return baseSteps[workflowType]['any'];
                }

                return baseSteps[workflowType]?.[pathKey]?.[electionKey] || baseSteps['summary']['any'];
            }

            calculateBriefService(classification, plea, electionMade) {
                if (plea === 'guilty') {
                    return 'Brief not required for guilty pleas';
                }

                const timeframes = {
                    'Summary Only': 'Brief served on request or court direction',
                    'Table 1': '6 weeks from first appearance (full brief if election made)',
                    'Table 2': '6 weeks from first appearance (full brief if prosecution elects)',
                    'Strictly Indictable': '6 weeks from first appearance (full brief required for committal)'
                };

                for (const [key, timeframe] of Object.entries(timeframes)) {
                    if (classification.includes(key)) {
                        return timeframe;
                    }
                }

                return '6 weeks from first appearance (standard rule)';
            }

            isElectionAvailable(classification) {
                if (classification.includes('Table 1')) {
                    return 'Either prosecution or defendant can elect District Court';
                }
                if (classification.includes('Table 2')) {
                    return 'Only prosecution can elect District Court';
                }
                if (classification.includes('Strictly Indictable')) {
                    return 'No election - must proceed on indictment';
                }
                return 'No election available - summary jurisdiction only';
            }

            calculateKeyDeadlines(classification, plea, electionMade) {
                const now = new Date();
                const deadlines = {};

                // Election period (if applicable)
                if (classification.includes('Table 1') || classification.includes('Table 2')) {
                    const electionDate = new Date(now);
                    electionDate.setDate(electionDate.getDate() + 28);
                    deadlines.election = {
                        date: electionDate.toLocaleDateString('en-AU'),
                        description: 'Last date for election to District Court',
                        daysFromNow: 28
                    };
                }

                // Brief service
                if (plea === 'not_guilty' || plea === 'not_entered') {
                    const briefDate = new Date(now);
                    briefDate.setDate(briefDate.getDate() + 42); // 6 weeks
                    deadlines.brief = {
                        date: briefDate.toLocaleDateString('en-AU'),
                        description: 'Prosecution must serve brief of evidence',
                        daysFromNow: 42
                    };
                }

                // Committal hearing (for indictable matters)
                if (classification.includes('Indictable') || electionMade) {
                    const committalDate = new Date(now);
                    committalDate.setDate(committalDate.getDate() + 84); // 12 weeks
                    deadlines.committal = {
                        date: committalDate.toLocaleDateString('en-AU'),
                        description: 'Committal proceedings',
                        daysFromNow: 84
                    };
                }

                return deadlines;
            }

            generateNextActions(steps) {
                const pendingSteps = steps.filter(step => !step.completed);
                if (pendingSteps.length === 0) return ['Matter complete'];
                
                const nextStep = pendingSteps[0];
                const actions = [`${nextStep.task} - ${nextStep.description}`];
                
                if (nextStep.deadline && nextStep.deadline.daysFromNow !== null) {
                    if (nextStep.deadline.daysFromNow <= 7) {
                        actions.push('⚠️ URGENT: Due within 7 days');
                    } else if (nextStep.deadline.daysFromNow <= 14) {
                        actions.push('⚠️ Due within 2 weeks');
                    }
                }
                
                return actions;
            }

            calculateDeadline(deadlineText) {
                const now = new Date();
                
                if (deadlineText.includes('weeks')) {
                    const weeks = parseInt(deadlineText.match(/(\d+)/)?.[1] || '0');
                    const deadline = new Date(now);
                    deadline.setDate(deadline.getDate() + (weeks * 7));
                    return {
                        text: deadlineText,
                        date: deadline.toLocaleDateString(),
                        daysFromNow: weeks * 7
                    };
                } else if (deadlineText.includes('Same day')) {
                    return {
                        text: deadlineText,
                        date: now.toLocaleDateString(),
                        daysFromNow: 0
                    };
                }
                
                return {
                    text: deadlineText,
                    date: 'TBD',
                    daysFromNow: null
                };
            }

            generateDocumentList(templateKey, pleaKey) {
                const baseDocuments = [
                    { name: 'Court Attendance Notice', required: true, deadline: 'Before first appearance' },
                    { name: 'Criminal record (if applicable)', required: false, deadline: 'Before sentencing' }
                ];

                if (pleaKey === 'not_guilty') {
                    baseDocuments.push(
                        { name: 'Brief of evidence', required: true, deadline: 'As per court order' },
                        { name: 'Defence response (if required)', required: false, deadline: 'Within time specified' }
                    );
                }

                if (templateKey === 'indictable' || templateKey === 'table1') {
                    baseDocuments.push(
                        { name: 'Election notice (if applicable)', required: false, deadline: 'Within election period' }
                    );
                }

                if (templateKey === 'indictable') {
                    baseDocuments.push(
                        { name: 'Case conference certificate', required: false, deadline: 'Before committal' },
                        { name: 'Committal bundle', required: true, deadline: 'For committal proceedings' }
                    );
                }

                return baseDocuments;
            }

            generatePracticeNotes(chargeInfo) {
                const notes = [];
                
                if (chargeInfo.classification.includes('Table 1')) {
                    notes.push('Both prosecution and defence can elect for the matter to proceed on indictment.');
                    notes.push('Consider the advantages/disadvantages of Local Court vs higher court jurisdiction.');
                }
                
                if (chargeInfo.classification.includes('Table 2')) {
                    notes.push('Only the prosecution can elect for the matter to proceed on indictment.');
                    notes.push('Defence should prepare for Local Court jurisdiction unless prosecution elects otherwise.');
                }
                
                if (chargeInfo.penalty) {
                    if (chargeInfo.penalty.years >= 2) {
                        notes.push('Serious penalty - consider all mitigating factors and character references.');
                    }
                    notes.push(`Maximum penalty: ${this.formatPenalty(chargeInfo.penalty)}`);
                }
                
                return notes;
            }

            formatPenalty(penalty) {
                const parts = [];
                if (penalty.years) parts.push(`${penalty.years} year${penalty.years > 1 ? 's' : ''} imprisonment`);
                if (penalty.months) parts.push(`${penalty.months} month${penalty.months > 1 ? 's' : ''} imprisonment`);
                if (penalty.units) parts.push(`${penalty.units} penalty units`);
                if (penalty.fine) parts.push(`$${penalty.fine.toLocaleString()} fine`);
                return parts.join(' or ');
            }

            generateFallbackWorkflow(chargeInfo, plea) {
                return {
                    classification: chargeInfo.classification,
                    plea: plea,
                    court: chargeInfo.court,
                    steps: [
                        { step: 1, task: 'First appearance in Local Court', deadline: { text: 'Initial court date', date: 'TBD', daysFromNow: null }, mandatory: true },
                        { step: 2, task: 'Enter plea', deadline: { text: 'Same day or adjourned', date: 'TBD', daysFromNow: null }, mandatory: true },
                        { step: 3, task: 'Proceed according to standard procedure', deadline: { text: 'As directed by court', date: 'TBD', daysFromNow: null }, mandatory: true }
                    ],
                    documents: [
                        { name: 'Court Attendance Notice', required: true, deadline: 'Before first appearance' }
                    ],
                    notes: ['Standard procedure applies - consult current legislation and court rules.']
                };
            }
        }

        // Global system instance
        class LegislativeSystem {
            constructor() {
                this.processor = new LegislativeProcessor();
                this.classifier = new ScheduleClassifier();
                this.search = new LegalSearch();
                this.workflow = new WorkflowEngine();
                this.loaded = false;
            }

            async initialize() {
                try {
                    await this.loadDefaultFiles();
                    this.loaded = true;
                    updateStatus('System initialized successfully', 'success');
                } catch (error) {
                    console.error('Initialization error:', error);
                    updateStatus('Failed to initialize system: ' + error.message, 'error');
                }
            }

            async loadDefaultFiles() {
                try {
                    updateStatus('Loading default legislation files...', 'loading');
                    
                    // Load Criminal Procedure Act
                    const cpaResponse = await fetch('./cpa1986188.txt');
                    if (cpaResponse.ok) {
                        const cpaText = await cpaResponse.text();
                        await this.processor.processLegislation(cpaText, 'Criminal Procedure Act 1986');
                        
                        // Parse Schedule 1 for classification
                        const scheduleMatch = cpaText.match(/Schedule 1.*$/s);
                        if (scheduleMatch) {
                            this.classifier.parseSchedule1(scheduleMatch[0]);
                        }
                    }
                    
                    // Load Crimes Act
                    const crimesResponse = await fetch('./ca190082.txt');
                    if (crimesResponse.ok) {
                        const crimesText = await crimesResponse.text();
                        await this.processor.processLegislation(crimesText, 'Crimes Act 1900');
                    }
                    
                    // Build search index
                    this.search.buildSearchIndex(this.processor);
                    
                    updateStatus(`Loaded ${this.processor.sections.size} sections from legislation files`, 'success');
                    
                } catch (error) {
                    console.error('Error loading files:', error);
                    updateStatus('Error loading default files: ' + error.message, 'error');
                }
            }
        }

        // Global instance
        const legislativeSystem = new LegislativeSystem();

        // UI Functions
        function updateStatus(message, type) {
            const statusDiv = document.getElementById('fileStatus');
            statusDiv.innerHTML = `<div class="status-indicator status-${type}">${message}</div>`;
        }

        function updateSuggestions(query) {
            const suggestionsList = document.getElementById('suggestionsList');
            
            if (query.length < 2) {
                suggestionsList.style.display = 'none';
                return;
            }

            const suggestions = legislativeSystem.search.getSuggestions(query);
            
            if (suggestions.length === 0) {
                suggestionsList.style.display = 'none';
                return;
            }

            suggestionsList.innerHTML = suggestions.map(suggestion => 
                `<div class="suggestion-item" onclick="selectSuggestion('${suggestion.value}')">${suggestion.text}</div>`
            ).join('');
            
            suggestionsList.style.display = 'block';
        }

        function selectSuggestion(value) {
            document.getElementById('searchBox').value = value;
            document.getElementById('suggestionsList').style.display = 'none';
            analyzeCharge();
        }

        async function loadDefaultFiles() {
            if (!legislativeSystem.loaded) {
                await legislativeSystem.initialize();
            } else {
                updateStatus('Default files already loaded', 'success');
            }
        }

        function clearFiles() {
            legislativeSystem.processor = new LegislativeProcessor();
            legislativeSystem.classifier = new ScheduleClassifier();
            legislativeSystem.search = new LegalSearch();
            legislativeSystem.loaded = false;
            updateStatus('Files cleared', 'warning');
            document.getElementById('resultsPanel').classList.remove('show');
            document.getElementById('workflowPanel').classList.remove('show');
        }

        function analyzeCharge() {
            const query = document.getElementById('searchBox').value.trim();
            if (!query) {
                alert('Please enter a section number or charge description');
                return;
            }

            if (!legislativeSystem.loaded) {
                updateStatus('Please load legislation files first', 'error');
                return;
            }

            updateStatus('Analyzing charge...', 'loading');

            // Extract potential charge value from query
            const chargeValue = extractChargeValue(query);
            
            // Search for the section
            const results = legislativeSystem.search.search(query);
            
            if (results.length === 0) {
                displayResults({
                    query: query,
                    found: false,
                    message: 'No matching sections found. The charge may be summary only, from legislation not yet loaded, or require manual analysis.'
                });
                return;
            }

            // Use the first result
            const sectionNumber = results[0];
            const sectionData = legislativeSystem.processor.extractSection('', sectionNumber);
            
            if (!sectionData) {
                displayResults({
                    query: query,
                    found: false,
                    message: 'Section found but details not available. Check section exists in loaded legislation.'
                });
                return;
            }

            console.log('Analyzing section:', sectionNumber, 'with value:', chargeValue);

            // Enhanced classification with value consideration
            const classification = legislativeSystem.classifier.classifyOffence(
                sectionNumber, 
                sectionData.penalty,
                chargeValue,
                { death: query.toLowerCase().includes('death') }
            );

            // Build comprehensive charge information
            const chargeInfo = {
                section: sectionNumber,
                title: sectionData.title,
                act: sectionData.act,
                penalty: sectionData.penalty,
                classification: classification.classification,
                court: classification.court,
                election: classification.election,
                reason: classification.reason,
                briefService: classification.briefService,
                electionPeriod: classification.electionPeriod,
                committalRequired: classification.committalRequired,
                note: classification.note,
                chargeValue: chargeValue
            };

            // Generate cross-references and related information
            const crossReferences = generateCrossReferences(chargeInfo);

            displayResults({
                query: query,
                found: true,
                chargeInfo: chargeInfo,
                relatedSections: results.slice(1, 4),
                crossReferences: crossReferences
            });

            updateStatus('Analysis complete', 'success');
        }

        function extractChargeValue(query) {
            // Extract dollar amounts from query
            const valuePattern = /\$?([\d,]+)(?:\.\d{2})?/g;
            const matches = query.match(valuePattern);
            
            if (matches && matches.length > 0) {
                // Take the largest value found
                const values = matches.map(match => 
                    parseInt(match.replace(/[$,]/g, ''))
                ).filter(val => !isNaN(val) && val > 0);
                
                return values.length > 0 ? Math.max(...values) : null;
            }
            
            return null;
        }

        function generateCrossReferences(chargeInfo) {
            const references = {
                bail: [],
                evidence: [],
                procedure: [],
                sentencing: [],
                jurisdiction: []
            };

            // Bail Act references
            if (chargeInfo.penalty) {
                const penaltyYears = legislativeSystem.classifier.calculateMaxPenalty(chargeInfo.penalty);
                
                if (penaltyYears >= 3) {
                    references.bail.push('Show cause provision may apply - Bail Act 2013 s.16B');
                }
                if (chargeInfo.section === '19A') {
                    references.bail.push('Exceptional circumstances required - Bail Act 2013 s.16BA');
                }
            }

            // Evidence Act references
            if (chargeInfo.title && chargeInfo.title.toLowerCase().includes('sexual')) {
                references.evidence.push('Special provisions apply - Evidence Act 1995 Part 2 Division 1');
                references.evidence.push('Complainant evidence provisions - Criminal Procedure Act Chapter 6 Part 5');
            }
            
            if (chargeInfo.title && chargeInfo.title.toLowerCase().includes('domestic')) {
                references.evidence.push('Domestic violence evidence provisions - Criminal Procedure Act Part 4B');
            }

            // Procedure references
            references.procedure.push(`Classification: ${chargeInfo.classification}`);
            
            if (chargeInfo.election && !chargeInfo.election.includes('No election')) {
                references.procedure.push(`Election rights: ${chargeInfo.election}`);
                references.procedure.push('Election procedures - Criminal Procedure Act ss.260-264');
            }

            if (chargeInfo.briefService) {
                references.procedure.push(`Brief service: ${chargeInfo.briefService}`);
            }

            // Jurisdiction references
            references.jurisdiction.push(`Primary court: ${chargeInfo.court}`);
            
            if (chargeInfo.classification.includes('Table')) {
                references.jurisdiction.push('Summary disposal provisions - Criminal Procedure Act Chapter 5');
            }

            // Sentencing references
            if (chargeInfo.penalty) {
                const penaltyYears = legislativeSystem.classifier.calculateMaxPenalty(chargeInfo.penalty);
                
                if (penaltyYears >= 5) {
                    references.sentencing.push('Standard non-parole period may apply - Crimes (Sentencing Procedure) Act');
                }
                
                if (chargeInfo.section && chargeInfo.section.startsWith('61')) {
                    references.sentencing.push('Sexual offence sentencing provisions may apply');
                }
            }

            return references;
        }

        // Enhanced workflow generation function
        function generateWorkflow() {
            if (!window.currentChargeInfo) {
                alert('Please analyze a charge first');
                return;
            }

            const plea = document.getElementById('pleaSelect').value;
            const court = document.getElementById('courtSelect').value;
            const electionMade = prompt('Has an election been made for District Court? (yes/no)', 'no')?.toLowerCase() === 'yes';
            
            updateStatus('Generating procedural workflow...', 'loading');

            const workflow = legislativeSystem.workflow.generateWorkflow(
                window.currentChargeInfo, 
                plea, 
                electionMade,
                window.currentChargeInfo.chargeValue
            );

            displayWorkflow(workflow);
            
            updateStatus('Workflow generated successfully', 'success');
        }

        // System validation function
        function validateSystem() {
            console.log('🔍 Running NSW Criminal Law Intelligence System Validation...');
            
            if (legislativeSystem.loaded) {
                // Run Schedule 1 classification tests
                legislativeSystem.classifier.validateClassification();
                
                // Test penalty extraction
                testPenaltyExtraction();
                
                // Test workflow generation
                testWorkflowGeneration();
                
                console.log('✅ System validation complete - check console for results');
                updateStatus('System validation complete - check console for detailed results', 'success');
            } else {
                console.log('❌ Cannot validate - legislation not loaded');
                updateStatus('Load legislation files first to run validation', 'warning');
            }
        }

        function testPenaltyExtraction() {
            console.log('\n📋 Testing penalty extraction...');
            
            const testCases = [
                { text: 'imprisonment for 5 years', expected: { years: 5 } },
                { text: '10 penalty units or imprisonment for 6 months', expected: { units: 10, months: 6 } },
                { text: 'life imprisonment', expected: { life: true } },
                { text: 'fine not exceeding $5,500', expected: { fine: 5500 } },
                { text: 'maximum penalty: 2 years imprisonment', expected: { years: 2 } }
            ];
            
            testCases.forEach(test => {
                const result = legislativeSystem.processor.extractPenalty(test.text);
                const passed = result && Object.keys(test.expected).every(key => result[key] === test.expected[key]);
                console.log(`${passed ? '✓' : '✗'} Penalty extraction: "${test.text}" - Expected:`, test.expected, 'Got:', result);
            });
        }

        function testWorkflowGeneration() {
            console.log('\n⚖️ Testing workflow generation...');
            
            const mockCharge = {
                section: '61I',
                title: 'Sexual assault',
                classification: 'Table 1',
                court: 'Local Court (unless elected)',
                penalty: { years: 5 }
            };
            
            const workflows = [
                { plea: 'guilty', election: false, description: 'Table 1 guilty plea, no election' },
                { plea: 'not_guilty', election: true, description: 'Table 1 not guilty plea, election made' }
            ];
            
            workflows.forEach(test => {
                const workflow = legislativeSystem.workflow.generateWorkflow(mockCharge, test.plea, test.election);
                console.log(`✓ Workflow generated for: ${test.description} - ${workflow.steps.length} steps`);
            });
        }

        function displayResults(results) {
            const resultsPanel = document.getElementById('resultsPanel');
            const resultsContent = document.getElementById('resultsContent');
            
            if (!results.found) {
                resultsContent.innerHTML = `
                    <div class="status-error">
                        <h3>No Results Found</h3>
                        <p><strong>Search:</strong> ${results.query}</p>
                        <p>${results.message}</p>
                    </div>
                `;
                resultsPanel.classList.add('show');
                return;
            }

            const charge = results.chargeInfo;
            const classificationClass = charge.classification.toLowerCase().replace(' ', '');
            
            let crossRefHtml = '';
            if (results.crossReferences) {
                crossRefHtml = `
                    <div class="cross-references">
                        <h4>Cross-References & Related Provisions</h4>
                        ${Object.entries(results.crossReferences).map(([category, refs]) => 
                            refs.length > 0 ? `
                                <div class="reference-category">
                                    <strong>${category.charAt(0).toUpperCase() + category.slice(1)}:</strong>
                                    <ul>${refs.map(ref => `<li>${ref}</li>`).join('')}</ul>
                                </div>
                            ` : ''
                        ).join('')}
                    </div>
                `;
            }

            resultsContent.innerHTML = `
                <div class="charge-summary">
                    <h3>${charge.act} - Section ${charge.section}</h3>
                    <h4>${charge.title}</h4>
                    
                    <div class="classification ${classificationClass}">${charge.classification}</div>
                    ${charge.reason ? `<p class="classification-reason"><strong>Reason:</strong> ${charge.reason}</p>` : ''}
                    ${charge.chargeValue ? `<p class="charge-value"><strong>Charge Value:</strong> $${charge.chargeValue.toLocaleString()}</p>` : ''}
                    
                    <div class="penalty-info">
                        <h4>Maximum Penalty</h4>
                        <p>${charge.penalty ? charge.penalty.text || legislativeSystem.workflow.formatPenalty(charge.penalty) : 'Not specified'}</p>
                    </div>
                    
                    <div class="jurisdiction-info">
                        <h4>Jurisdiction & Procedure</h4>
                        <p><strong>Court:</strong> ${charge.court}</p>
                        <p><strong>Election Rights:</strong> ${charge.election}</p>
                        ${charge.briefService ? `<p><strong>Brief Service:</strong> ${charge.briefService}</p>` : ''}
                        ${charge.electionPeriod ? `<p><strong>Election Period:</strong> ${charge.electionPeriod}</p>` : ''}
                        ${charge.committalRequired ? `<p><strong>Committal:</strong> Required</p>` : ''}
                        ${charge.note ? `<p class="status-warning"><strong>Note:</strong> ${charge.note}</p>` : ''}
                    </div>
                    
                    ${crossRefHtml}
                    
                    ${results.relatedSections.length > 0 ? `
                        <div class="related-sections">
                            <h4>Related Sections Found</h4>
                            <p>${results.relatedSections.join(', ')}</p>
                        </div>
                    ` : ''}
                    
                    <div class="analysis-info">
                        <p><small><em>Analysis based on NSW Criminal Procedure Act 1986 Schedule 1 and penalty provisions</em></small></p>
                    </div>
                </div>
            `;
            
            resultsPanel.classList.add('show');
            
            // Store charge info for workflow generation
            window.currentChargeInfo = charge;
        }

        function generateWorkflow() {
            if (!window.currentChargeInfo) {
                alert('Please analyze a charge first');
                return;
            }

            const plea = document.getElementById('pleaSelect').value;
            const court = document.getElementById('courtSelect').value;
            
            const workflow = legislativeSystem.workflow.generateWorkflow(
                window.currentChargeInfo, 
                plea, 
                court
            );

            displayWorkflow(workflow);
        }

        function displayWorkflow(workflow) {
            const workflowPanel = document.getElementById('workflowPanel');
            const workflowContent = document.getElementById('workflowContent');
            
            const pleaText = workflow.plea === 'guilty' ? 'Guilty Plea' : 
                           workflow.plea === 'not_guilty' ? 'Not Guilty Plea' : 'No Plea Yet';
            
            workflowContent.innerHTML = `
                <div class="workflow-summary">
                    <h3>Procedural Workflow</h3>
                    <p><strong>Classification:</strong> ${workflow.classification}</p>
                    <p><strong>Plea:</strong> ${pleaText}</p>
                    <p><strong>Court:</strong> ${workflow.court}</p>
                </div>
                
                <div class="workflow-timeline">
                    <h4>Procedural Steps</h4>
                    ${workflow.steps.map(step => `
                        <div class="timeline-item">
                            <div class="step">${step.step}</div>
                            <div class="content">
                                <h4>${step.task}</h4>
                                <p><strong>Deadline:</strong> ${step.deadline.text}</p>
                                ${step.deadline.date !== 'TBD' ? `<p><strong>Date:</strong> ${step.deadline.date}</p>` : ''}
                                ${step.mandatory ? '<span class="classification summary">Mandatory</span>' : '<span class="classification table2">Optional</span>'}
                            </div>
                        </div>
                    `).join('')}
                </div>
                
                <div class="documents-checklist">
                    <h4>Required Documents</h4>
                    ${workflow.documents.map(doc => `
                        <div class="checklist-item">
                            <input type="checkbox" id="doc-${doc.name.replace(/\s/g, '')}" ${doc.required ? 'required' : ''}>
                            <label for="doc-${doc.name.replace(/\s/g, '')}">${doc.name} ${doc.required ? '(Required)' : '(Optional)'}</label>
                            <small>Deadline: ${doc.deadline}</small>
                        </div>
                    `).join('')}
                </div>
                
                <div class="practice-notes">
                    <h4>Practice Notes</h4>
                    <ul>
                        ${workflow.notes.map(note => `<li>${note}</li>`).join('')}
                    </ul>
                </div>
            `;
            
            workflowPanel.classList.add('show');
            
            // Store workflow for export
            window.currentWorkflow = workflow;
        }

        function exportWorkflow(format) {
            if (!window.currentWorkflow) {
                alert('Please generate a workflow first');
                return;
            }

            const workflow = window.currentWorkflow;
            
            switch (format) {
                case 'copy':
                    exportToClipboard(workflow);
                    break;
                case 'print':
                    exportToPrint(workflow);
                    break;
                case 'pdf':
                    alert('PDF export would require a PDF library - implementing print instead');
                    exportToPrint(workflow);
                    break;
                default:
                    alert('Export format not supported yet');
            }
        }

        function exportToClipboard(workflow) {
            const text = `
NSW Criminal Law Procedural Workflow

Classification: ${workflow.classification}
Court: ${workflow.court}
Plea: ${workflow.plea}

Procedural Steps:
${workflow.steps.map(step => `${step.step}. ${step.task} (Deadline: ${step.deadline.text})`).join('\n')}

Required Documents:
${workflow.documents.map(doc => `- ${doc.name} ${doc.required ? '(Required)' : '(Optional)'} - ${doc.deadline}`).join('\n')}

Practice Notes:
${workflow.notes.map(note => `- ${note}`).join('\n')}

Generated by NSW Criminal Law Legislative Intelligence System
            `.trim();

            navigator.clipboard.writeText(text).then(() => {
                alert('Workflow copied to clipboard!');
            }).catch(() => {
                alert('Failed to copy to clipboard');
            });
        }

        function exportToPrint(workflow) {
            const printContent = document.getElementById('workflowContent').innerHTML;
            const printWindow = window.open('', '_blank');
            printWindow.document.write(`
                <html>
                <head>
                    <title>NSW Criminal Law Workflow</title>
                    <style>
                        body { font-family: Arial, sans-serif; margin: 20px; }
                        .timeline-item { margin: 15px 0; padding: 10px; border-left: 3px solid #2a5298; }
                        .step { background: #2a5298; color: white; width: 25px; height: 25px; border-radius: 50%; display: inline-block; text-align: center; line-height: 25px; margin-right: 10px; }
                        .classification { padding: 4px 8px; border-radius: 10px; font-size: 12px; }
                        .classification.summary { background: #d4edda; color: #155724; }
                        .checklist-item { margin: 8px 0; }
                        @media print { body { margin: 0; } }
                    </style>
                </head>
                <body>
                    <h1>NSW Criminal Law Procedural Workflow</h1>
                    ${printContent}
                    <hr>
                    <p><small>Generated by NSW Criminal Law Legislative Intelligence System</small></p>
                </body>
                </html>
            `);
            printWindow.document.close();
            printWindow.print();
        }

        // Event Listeners
        document.addEventListener('DOMContentLoaded', function() {
            // File upload functionality
            const fileUploadArea = document.getElementById('fileUploadArea');
            const fileInput = document.getElementById('fileInput');

            fileUploadArea.addEventListener('click', () => fileInput.click());
            
            fileUploadArea.addEventListener('dragover', (e) => {
                e.preventDefault();
                fileUploadArea.classList.add('dragover');
            });

            fileUploadArea.addEventListener('dragleave', () => {
                fileUploadArea.classList.remove('dragover');
            });

            fileUploadArea.addEventListener('drop', (e) => {
                e.preventDefault();
                fileUploadArea.classList.remove('dragover');
                handleFiles(e.dataTransfer.files);
            });

            fileInput.addEventListener('change', (e) => {
                handleFiles(e.target.files);
            });

            // Search functionality
            const searchBox = document.getElementById('searchBox');
            let searchTimeout;

            searchBox.addEventListener('input', (e) => {
                clearTimeout(searchTimeout);
                searchTimeout = setTimeout(() => {
                    updateSuggestions(e.target.value);
                }, 300);
            });

            searchBox.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    analyzeCharge();
                    document.getElementById('suggestionsList').style.display = 'none';
                } else if (e.key === 'Escape') {
                    document.getElementById('suggestionsList').style.display = 'none';
                }
            });

            // Hide suggestions when clicking outside
            document.addEventListener('click', (e) => {
                if (!e.target.closest('.search-position')) {
                    document.getElementById('suggestionsList').style.display = 'none';
                }
            });

            // Initialize system
            updateStatus('System ready - click "Load Default Files" to begin', 'warning');
        });

        async function handleFiles(files) {
            updateStatus('Processing uploaded files...', 'loading');
            
            for (const file of files) {
                if (file.type === 'text/plain' || file.name.endsWith('.txt')) {
                    try {
                        const text = await file.text();
                        const actName = file.name.replace('.txt', '').replace(/[_-]/g, ' ');
                        await legislativeSystem.processor.processLegislation(text, actName);
                        
                        // If it's a Criminal Procedure Act file, parse Schedule 1
                        if (file.name.toLowerCase().includes('cpa') || actName.toLowerCase().includes('criminal procedure')) {
                            const scheduleMatch = text.match(/Schedule 1.*$/s);
                            if (scheduleMatch) {
                                legislativeSystem.classifier.parseSchedule1(scheduleMatch[0]);
                            }
                        }
                    } catch (error) {
                        console.error('Error processing file:', error);
                        updateStatus(`Error processing ${file.name}: ${error.message}`, 'error');
                        return;
                    }
                }
            }
            
            // Rebuild search index
            legislativeSystem.search.buildSearchIndex(legislativeSystem.processor);
            legislativeSystem.loaded = true;
            
            updateStatus(`Successfully processed ${files.length} file(s). System ready.`, 'success');
        }
    </script>
</body>
</html>
